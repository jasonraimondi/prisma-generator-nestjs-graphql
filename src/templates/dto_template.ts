import { DMMF } from "@prisma/generator-helper";
import {
  importRelations,
  graphqlType,
  shouldHide,
  isRequired,
  needsIDField,
  type,
  validationBlocks,
  importValidations,
} from "./model_template";

// @ts-ignore
export const isAutoIncrement = (field: DMMF.Field): boolean => field.default?.name === "autoincrement";

export const autoGeneratedMessage = `
/////////////////////////////////////
// DO NOT EDIT THIS FILE DIRECTLY,
// THIS FILE WAS AUTO GENERATED.
/////////////////////////////////////


`;

type GenerateDtoTemplateArgs = {
  clientPath: string;
  prefix: string;
}

export function generateDtoTemplate(args: GenerateDtoTemplateArgs, model: DMMF.Model) {
  const { clientPath, prefix } = args;

  const createField = (field: DMMF.Field) => {
    const skip = field.isUpdatedAt || field.name === "createdAt";

    if (skip) return "";

    if (field.isId) {
      const required = field.isRequired && !field.hasDefaultValue;
      // @ts-ignore
      return `
          ${validationBlocks(field.documentation)}
          @Field(() => ID, { nullable: ${!required} })  
          ${field.name}${required ? "!" : "?"}: ${type(field, { prefix })}
        `;
    }

    const required = field.name !== "createdAt" && isRequired(field);

    return `
      ${validationBlocks(field.documentation)}
      @Field(() => ${graphqlType(field, { prefix })}, { nullable: ${!required} })  
      ${field.name}${required ? "!" : "?"}: ${type(field, { prefix })}
    `;
  };

  const updateField = (field: DMMF.Field) => {
    if (shouldHide(field.documentation) || field.isUpdatedAt || field.name.startsWith("created")) return "";
    return `
@Field(() => ${field.isId ? "ID!" : graphqlType(field, {
      forceOptional: true,
      prefix,
    })}, { nullable: ${!field.isId} })  
${field.name}${field.isId ? "!" : "?"}: ${type(field, { prefix })}
`;
  };

  const whereField = (field: DMMF.Field) => {
    return `
@Field(() => ${field.isId ? "ID" : graphqlType(field, {
      forceOptional: true,
      prefix,
    })}, { nullable: true })  
${field.name}?: ${type(field, { prefix })}
`;
  };

  const hasRelatedFields = (f: DMMF.Field) =>
    !model.fields
      .filter(f => f.relationName)
      .map(f => f.name)
      .filter(relation => f.name.startsWith(relation)).length;

  const addEnumImports = (clientPath: string, model: DMMF.Model) => {
    const enums = model.fields.filter(f => f.kind == "enum");
    return enums.length ? `import { ${enums.map(f => f.type)} } from "${clientPath}";` : "";
  };

  const extraInputs = (model: DMMF.Model) => {
    const inputs: string[] = [];
    model.fields
      .filter(f => !f.isId)
      .filter(f => !f.relationName)
      .filter(f => !f.isUpdatedAt)
      .forEach(f => {
        if (f.type === "Int") inputs.push("Int");
      });
    return [...new Set(inputs)];
  };

  return `
${autoGeneratedMessage}
  
import { 
  Field, 
  InputType, 
  ${needsIDField(model) ? "ID," : ""} 
  ${extraInputs(model)} 
} from "@nestjs/graphql";
${addEnumImports(clientPath, model)}
${importRelations(model, { filterOutRelations: true, prefix })}
${importValidations(model)}
import { ${model.name}Constructor } from "./${model.name}.model";
import { PaginatorInputs } from "./paginator";

@InputType()
export class ${model.name}CreateInput implements ${model.name}Constructor {
${model.fields
    .filter(f => !f.relationName)
    .filter(f => !f.isUpdatedAt)
    .map(createField)
    .join("")}
}

@InputType()
export class ${model.name}UpdateInput {
${model.fields
    .filter(f => !f.relationName)
    .filter(f => !f.isUpdatedAt)
    .filter(hasRelatedFields)
    .map(updateField)
    .join("")}
}

@InputType()
export class ${model.name}WhereInput {
${model.fields
    .filter(f => !f.relationName)
    .filter(f => !f.isUpdatedAt)
    .filter(f => !f.name.startsWith("created"))
    .filter(f => !shouldHide(f.documentation))
    .map(whereField)
    .join("")}
}

@InputType()
export class ${model.name}PaginatorInput extends PaginatorInputs {
}
`;
}
